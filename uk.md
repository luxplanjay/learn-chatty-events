# Chatty Events

Досить часто у фронтенді виникає потреба обробити зміну розміру вікна (`resize`), прокручування сторінки (`scroll`), рух миші (`mousemove`) або введення тексту (`input`, `keydown`). Це може бути сортування колекції, анімація елементів, оновлення інтерфейсу або маніпуляції з DOM-деревом. Такі дії справді покращують UX (user experience), але водночас створюють **значне навантаження на браузер**, адже обробники подій у цих випадках спрацьовують **надто часто**.

> **Chatty events** — це події в браузері або в будь-якій системі, які **виникають надмірно часто й інтенсивно**, створюючи **зайве навантаження** на JavaScript-потік і ресурси пристрою.

Наприклад, якщо ви додали обробник події `scroll`, то під час прокручування сторінки мишкою він може викликатися **30-60 разів на секунду**. А повільне свайпання на смартфоні — до **100 подій на секунду**.

Уявіть, що в такому обробнику ви виконуєте:

- Маніпуляції з DOM
- Обчислення позицій елементів
- Фільтрацію чи сортування великих масивів

У такому випадку ви гарантовано отримаєте **помітне зниження продуктивності** — особливо на слабких пристроях або в старих браузерах.

Основні наслідки Chatty Events:

- **Просідання FPS** та втрата плавності інтерфейсу
- **Ривки в анімаціях** і скролі
- **Високе навантаження на процесор**
- **Лаги** під час взаємодії з інтерфейсом
- Втрата кадрів (drop frames), особливо при `scroll` і `resize`

## Як зменшити частоту виклику обробників

Щоб уникнути надмірної кількості викликів функції при роботі з chatty events, використовують техніки **throttle** та **debounce**.

Це два схожих за призначенням, але різних за поведінкою прийоми, які дозволяють **контролювати частоту виклику функції** з часом:

- **Throttle** — викликає функцію **не частіше**, ніж раз у певний інтервал часу.
- **Debounce** — викликає функцію **тільки після паузи**, коли події припинились.

> У сучасних проєктах ми зазвичай підключаємо ці функції з бібліотеки [**Lodash**](https://lodash.com/), яка надає перевірені реалізації throttle і debounce.

Далі ми встановимо Lodash і перейдемо до практичних прикладів.

## Підключення бібліотеки

Ми використовуємо сучасне середовище розробки, тому бібліотеку [**Lodash**](https://lodash.com/) підключимо через менеджер пакетів `npm`.

У терміналі в корені проєкту виконайте команду:

```bash
npm install lodash
```

Щоб не тягнути в бандл всю бібліотеку, краще імпортувати лише конкретні функції, які вам потрібні. Наприклад, `throttle` та `debounce`:

```jsx
import throttle from "lodash/throttle";
import debounce from "lodash/debounce";
```

Можемо перевірити, що бібліотека працює. Імпортуємо просту функцію `add` та виконаємо додавання:

```jsx
import add from "lodash/add";

const result = add(2, 3);
console.log(result); // 5
```

Готово — тепер ви можете використовувати функції `throttle`, `debounce` та інші утиліти Lodash без зайвого навантаження на сторінку.

## Throttle

`Throttle` — це техніка, яка дозволяє **обмежити частоту виклику функції**: вона буде виконуватись **не частіше одного разу** за вказаний інтервал часу (`N` мілісекунд), навіть якщо подія спрацьовує частіше.

Інакше кажучи: браузер може генерувати подію `scroll` чи `mousemove` десятки разів на секунду, але обробник з `throttle` буде викликатись, наприклад, лише раз на 300 мс — і не частіше.

> `Throttle` гарантує **регулярне**, але **обмежене за частотою** виконання обробника.

![Ілюстрація принципу роботи throttle](/assets/throttle.png)

Використовуючи `throttle`, ми не контролюємо, як часто браузер буде генерувати події. Ми всього-на-всього беремо контроль над частотою виконання функції обробника події.

```jsx
import throttle from "lodash/throttle";

document.addEventListener(
  "scroll",
  throttle(() => {
    console.log("Scroll handler call every 300ms");
  }, 300)
);
```

У цьому прикладі:

- Ми використовуємо `throttle` з Lodash.
- Першим аргументом передається функція, яку потрібно "загальмувати".
- Другим аргументом — інтервал у мілісекундах (300 мс).
- `throttle` повертає **нову функцію**, яку ми передаємо до слухача події.

Коли використовувати throttle.

- При `scroll` — оновлення позиції елементів, lazy-loading, зміна стилю шапки.
- При `mousemove` — наприклад, обчислення координат курсора.
- При `resize` — зміна layout або оновлення розмітки.

## Debounce

`Debounce` — це техніка, яка **відкладає виклик функції** доти, доки подія не припиниться на заданий час.

> Іншими словами: функція буде викликана **лише після паузи** у `N` мілісекунд після останньої події.

Наприклад: користувач скролить сторінку — подія `scroll` спрацьовує десятки разів на секунду, але функція не викликається, поки скрол не зупиниться. Якщо користувач перестав скролити — `debounce` зачекає 300 мс, і тільки тоді виконає функцію. Якщо ж за цей час користувач знову почне скролити — таймер скинеться.

![Ілюстрація принципу роботи debounce](/assets/debounce.png)

Використовуючи `debounce`, ми не контролюємо тe, як часто браузер буде генерувати події, а всього лише беремо контроль над частотою виконання функції обробника події.

```jsx
import debounce from "lodash/debounce";

document.addEventListener(
  "scroll",
  debounce(() => {
    console.log("Scroll handler call after 300ms pause");
  }, 300)
);
```

У цьому прикладі:

- Першим аргументом передається функція, яку треба викликати після паузи.
- Другим — тривалість паузи (300 мс).
- `debounce` повертає **нову функцію**, яку ми передаємо в обробник події.

Коли використовувати debounce.

- При `input` — щоб не запускати пошук під час кожного натискання клавіші.
- При `scroll` — якщо потрібно оновити щось лише після завершення прокручування.
- При `resize` — щоб перерахувати layout тільки після завершення зміни розміру.

## Режими методу `debounce`

За замовчуванням `debounce` працює у так званому `trailing edge` режимі — це означає, що функція викликається після завершення серії подій, тобто через `N` мілісекунд паузи після останнього виклику події.

Але іноді потрібна інша поведінка — виклик функції **на початку серії подій**, ігноруючи усі наступні події до завершення інтервалу. Такий режим називається `leading edge`.

Різниця між режимами:

- **Trailing edge** (`trailing: true`) — функція викликається **в кінці**, коли користувач перестав взаємодіяти.
- **Leading edge** (`leading: true`) — функція викликається **на старті**, після чого ігнорує решту подій, поки не настане нова пауза.

![Ілюстрація принципу роботи debounce в режимі leading edge](/assets/debounce-leading.png)

Метод `debounce` з бібліотеки Lodash приймає **третім аргументом об’єкт налаштувань**, де можна вказати:

- `leading: true` — виклик функції **на початку серії подій**
- `trailing: true` — виклик функції **в кінці серії подій** (після паузи)

> За замовчуванням: `{ leading: false, trailing: true }`

```jsx
import debounce from "lodash/debounce";

document.addEventListener(
  "scroll",
  debounce(
    () => {
      console.log("Scroll handler call on every event stream start");
    },
    300,
    {
      leading: true,
      trailing: false,
    }
  )
);
```

У цьому прикладі:

- Обробник викликається **на початку скролу**, але **не буде повторно викликаний**, поки не мине 300 мс паузи.
- Новий виклик знову відбудеться лише після чергової паузи й нового старту подій.

Коли використовувати режим `leading`

- Надсилання запиту при **першому натисканні** кнопки
- Початок анімації одразу після першої дії
- Визначення старту взаємодії (наприклад, початок скролу, свайпу, натискання)
